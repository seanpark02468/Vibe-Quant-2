# -*- coding: utf-8 -*-
"""backtester_client

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SjIsdE1RTEgJAU0-7MF0IVWC6oLULNEc
"""

# /clients/backtester_client.py

import pandas as pd
import lightgbm as lgb
from scipy.stats import pearsonr
import streamlit as st
import os
import gdown
import pyarrow
import inspect
from core import operators
# from ..config import DATA_PATH

class BacktesterClient:
    """
    ë°ì´í„° ë¡œë”© ë° ê°„ì†Œí™”ëœ ë°±í…ŒìŠ¤íŒ…ì„ ìˆ˜í–‰í•˜ëŠ” í´ë¼ì´ì–¸íŠ¸.
    LightGBM ëª¨ë¸ì„ ì‚¬ìš©í•˜ì—¬ íŒ©í„°ì˜ ì˜ˆì¸¡ë ¥ì„ í‰ê°€í•˜ê³  ì •ë³´ ê³„ìˆ˜(IC)ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
    """
    # def __init__(self):
    #     """
    #     í´ë¼ì´ì–¸íŠ¸ë¥¼ ì´ˆê¸°í™”í•˜ê³  ë°ì´í„°ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤.
    #     """
    #     self.stock_data = self.load_data()

    def __init__(self):
        """
        í´ë¼ì´ì–¸íŠ¸ë¥¼ ì´ˆê¸°í™”í•˜ê³  ë°ì´í„°ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤.
        """
        self.stock_data = self.load_data()
        if not self.stock_data.empty:
            # operators.pyì˜ í•¨ìˆ˜ë“¤ì´ ì˜¬ë°”ë¥´ê²Œ ì‘ë™í•˜ë ¤ë©´ ë©€í‹° ì¸ë±ìŠ¤ê°€ í•„ìˆ˜ì…ë‹ˆë‹¤.
            if not isinstance(self.stock_data.index, pd.MultiIndex):
                self.stock_data.set_index(['date', 'ticker'], inplace=True)
                self.stock_data.sort_index(inplace=True)

    # def load_data(self) -> pd.DataFrame:
    #     """
    #     êµ¬ê¸€ ë“œë¼ì´ë¸Œì—ì„œ Parquet í˜•ì‹ì˜ ì£¼ì‹ ë°ì´í„°ë¥¼ ë‹¤ìš´ë¡œë“œí•˜ì—¬ ë¡œë“œí•©ë‹ˆë‹¤.
    #     """
    #     output_path = 'kor_stocks.parquet'
        
    #     # íŒŒì¼ì´ ì´ë¯¸ ë¡œì»¬ì— ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²½ìš°ì—ë§Œ ë‹¤ìš´ë¡œë“œ
    #     if not os.path.exists(output_path):
    #         try:
    #             with st.spinner("êµ¬ê¸€ ë“œë¼ì´ë¸Œì—ì„œ ì£¼ì‹ ë°ì´í„°ë¥¼ ë‹¤ìš´ë¡œë“œ ì¤‘ì…ë‹ˆë‹¤..."):
    #                 gdown.download(id=st.secrets["GOOGLE_DRIVE_FILE_ID"], output=output_path, quiet=False, fuzzy=True)
    #         except Exception as e:
    #             st.error(f"êµ¬ê¸€ ë“œë¼ì´ë¸Œ íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
    #             return pd.DataFrame()

    #     # ë‹¤ìš´ë¡œë“œëœ ë¡œì»¬ íŒŒì¼ì„ ì½ìŠµë‹ˆë‹¤.
    #     try:
    #         df = pd.read_parquet(output_path)
    #         df['date'] = pd.to_datetime(df['date'])
    #         df.sort_values(by=['ticker', 'date'], inplace=True)
    #         df.reset_index(drop=True, inplace=True)
    #         return df
    #     except FileNotFoundError:
    #         st.error(f"ë‹¤ìš´ë¡œë“œëœ ë°ì´í„° íŒŒì¼({output_path})ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    #         return pd.DataFrame()
    #     except Exception as e:
    #         st.error(f"ë°ì´í„° ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
    #         return pd.DataFrame()

    def load_data(self) -> pd.DataFrame:
        """
        êµ¬ê¸€ ë“œë¼ì´ë¸Œì—ì„œ Parquet í˜•ì‹ì˜ ì£¼ì‹ ë°ì´í„°ë¥¼ ë‹¤ìš´ë¡œë“œí•˜ì—¬ ë¡œë“œí•©ë‹ˆë‹¤.
        ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨ ë° íŒŒì¼ ì†ìƒì„ ì²˜ë¦¬í•˜ëŠ” ë¡œì§ì´ ê°•í™”ë˜ì—ˆìŠµë‹ˆë‹¤.
        """
        output_path = 'kor_stocks.parquet'
        
        # íŒŒì¼ì´ ë¡œì»¬ì— ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²½ìš°ì—ë§Œ ë‹¤ìš´ë¡œë“œ
        if not os.path.exists(output_path):
            try:
                with st.spinner("êµ¬ê¸€ ë“œë¼ì´ë¸Œì—ì„œ ì£¼ì‹ ë°ì´í„°ë¥¼ ë‹¤ìš´ë¡œë“œ ì¤‘ì…ë‹ˆë‹¤... (íŒŒì¼ í¬ê¸°ì— ë”°ë¼ ì‹œê°„ì´ ê±¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤)"):
                    # gdown.downloadì˜ ê²°ê³¼ë¥¼ ë³€ìˆ˜ë¡œ ë°›ì•„ ì„±ê³µ ì—¬ë¶€ í™•ì¸
                    downloaded_path = gdown.download(id=st.secrets["GOOGLE_DRIVE_FILE_ID"], output=output_path, quiet=False)
                    if downloaded_path is None:
                        st.error("íŒŒì¼ ë‹¤ìš´ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. êµ¬ê¸€ ë“œë¼ì´ë¸Œ íŒŒì¼ IDì™€ ê³µìœ  ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.")
                        return pd.DataFrame()
            except Exception as e:
                st.error(f"êµ¬ê¸€ ë“œë¼ì´ë¸Œ íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì¤‘ ì‹¬ê°í•œ ì˜¤ë¥˜ ë°œìƒ: {e}")
                # ì‹¤íŒ¨ ì‹œ ë¶ˆì™„ì „í•œ íŒŒì¼ì´ ë‚¨ì•„ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì‚­ì œ
                if os.path.exists(output_path):
                    os.remove(output_path)
                return pd.DataFrame()

        # ë‹¤ìš´ë¡œë“œëœ ë¡œì»¬ íŒŒì¼ì„ ì½ê³  ìœ íš¨ì„±ì„ ê²€ì‚¬í•©ë‹ˆë‹¤.
        try:
            df = pd.read_parquet(output_path)
            df['date'] = pd.to_datetime(df['date'])
            df.sort_values(by=['ticker', 'date'], inplace=True)
            df.reset_index(drop=True, inplace=True)
            st.success("ë°ì´í„° ë¡œë”© ì™„ë£Œ!")
            return df
        except pyarrow.lib.ArrowInvalid as e: # Parquet íŒŒì¼ì´ ì•„ë‹ ë•Œ ë°œìƒí•˜ëŠ” íŠ¹ì • ì˜¤ë¥˜
            st.error(f"ë‹¤ìš´ë¡œë“œëœ íŒŒì¼ì´ ìœ íš¨í•œ Parquet í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤. íŒŒì¼ì„ ì‚­ì œí•˜ê³  ì¬ì‹œë„í•©ë‹ˆë‹¤. ì˜¤ë¥˜: {e}")
            # ì†ìƒëœ íŒŒì¼ ì‚­ì œ
            os.remove(output_path)
            return pd.DataFrame()
        except FileNotFoundError:
            st.error(f"ë°ì´í„° íŒŒì¼({output_path})ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            return pd.DataFrame()
        except Exception as e:
            st.error(f"ë°ì´í„° ë¡œë“œ ì¤‘ ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ ë°œìƒ: {e}")
            return pd.DataFrame()
    
    # def run_backtest(self, factor_expression: str) -> float:
    #     """
    #     ì£¼ì–´ì§„ íŒ©í„° í‘œí˜„ì‹ì„ í‰ê°€í•˜ê³  LightGBMì„ ì‚¬ìš©í•˜ì—¬ ë°±í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.

    #     Args:
    #         factor_expression (str): í‰ê°€í•  ì•ŒíŒŒ íŒ©í„°ì˜ ë¬¸ìì—´ í‘œí˜„ì‹.
    #                                  (ì˜ˆ: 'close / open - 1')

    #     Returns:
    #         float: ê³„ì‚°ëœ ì •ë³´ ê³„ìˆ˜(IC). ì˜¤ë¥˜ ë°œìƒ ì‹œ 0.0ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    #     """
    #     if self.stock_data.empty:
    #         st.warning("ì£¼ì‹ ë°ì´í„°ê°€ ì—†ì–´ ë°±í…ŒìŠ¤íŒ…ì„ ê±´ë„ˆëœë‹ˆë‹¤.")
    #         return 0.0

    #     try:
    #         # 1. íŒ©í„° ê°’ ê³„ì‚° (pd.eval ì‚¬ìš©)
    #         # 'self.stock_data'ì˜ ì»¬ëŸ¼ì„ ì§€ì—­ ë³€ìˆ˜ì²˜ëŸ¼ ì‚¬ìš©í•˜ì—¬ í‘œí˜„ì‹ ê³„ì‚°
    #         # ë³´ì•ˆ ì°¸ê³ : ì‹¤ì œ ì„œë¹„ìŠ¤ì—ì„œëŠ” eval ì‚¬ìš©ì— ë§¤ìš° ì‹ ì¤‘í•´ì•¼ í•©ë‹ˆë‹¤.
    #         # ì´ í”„ë¡œì íŠ¸ì—ì„œëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ìƒì„±ëœ íŒ©í„°ë§Œ ì‚¬ìš©í•˜ë¯€ë¡œ ì œí•œì ìœ¼ë¡œ í—ˆìš©í•©ë‹ˆë‹¤.
    #         factor_values = self.stock_data.eval(factor_expression, engine='python')

    #         # 2. ì˜ˆì¸¡ ëŒ€ìƒ(target) ìƒì„±: ë‹¤ìŒ ë‚ ì˜ ìˆ˜ìµë¥ 
    #         # ê·¸ë£¹ë³„(ticker)ë¡œ ìˆ˜ìµë¥ ì„ ê³„ì‚°í•˜ì—¬ ë°ì´í„° ì™œê³¡ ë°©ì§€
    #         target = self.stock_data.groupby('ticker')['close'].pct_change(1).shift(-1)

    #         # 3. ë°ì´í„°ì…‹ ì¤€ë¹„
    #         df_backtest = pd.DataFrame({
    #             'factor': factor_values,
    #             'target': target
    #         }).dropna()

    #         if len(df_backtest) < 100: # í•™ìŠµì— í•„ìš”í•œ ìµœì†Œ ë°ì´í„° ìˆ˜
    #             st.warning("ë°±í…ŒìŠ¤íŒ…ì— ì‚¬ìš©í•  ë°ì´í„°ê°€ ë„ˆë¬´ ì ìŠµë‹ˆë‹¤.")
    #             return 0.0

    #         X = df_backtest[['factor']]
    #         y = df_backtest['target']

    #         # 4. LightGBM ëª¨ë¸ í•™ìŠµ ë° ì˜ˆì¸¡
    #         model = lgb.LGBMRegressor(random_state=42, n_estimators=100)
    #         model.fit(X, y)
    #         predictions = model.predict(X)

    #         # 5. ì •ë³´ ê³„ìˆ˜(IC) ê³„ì‚°
    #         # í”¼ì–´ìŠ¨ ìƒê´€ê³„ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì˜ˆì¸¡ê°’ê³¼ ì‹¤ì œê°’ì˜ ìƒê´€ê´€ê³„ ì¸¡ì •
    #         ic, _ = pearsonr(predictions, y)

    #         return float(ic)

    #     except Exception as e:
    #         # st.warning(f"'{factor_expression}' íŒ©í„° ë°±í…ŒìŠ¤íŒ… ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
    #         # ìœ íš¨í•˜ì§€ ì•Šì€ íŒ©í„° í‘œí˜„ì‹ì´ ë§ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ê²½ê³ ëŠ” ì£¼ì„ ì²˜ë¦¬
    #         return 0.0

    # def run_backtest(self, factor_expression: str) -> float:
    #     """
    #     ì£¼ì–´ì§„ íŒ©í„° í‘œí˜„ì‹ì„ í‰ê°€í•˜ê³  LightGBMì„ ì‚¬ìš©í•˜ì—¬ ë°±í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.

    #     Args:
    #         factor_expression (str): í‰ê°€í•  ì•ŒíŒŒ íŒ©í„°ì˜ ë¬¸ìì—´ í‘œí˜„ì‹.
    #                                  (ì˜ˆ: 'close / open - 1')

    #     Returns:
    #         float: ê³„ì‚°ëœ ì •ë³´ ê³„ìˆ˜(IC). ì˜¤ë¥˜ ë°œìƒ ì‹œ 0.0ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    #     """
    #     if self.stock_data.empty:
    #         st.warning("ì£¼ì‹ ë°ì´í„°ê°€ ì—†ì–´ ë°±í…ŒìŠ¤íŒ…ì„ ê±´ë„ˆëœë‹ˆë‹¤.")
    #         return 0.0

    #     try:
    #         # 1. íŒ©í„° ê°’ ê³„ì‚° (pd.eval ì‚¬ìš©)
    #         factor_values = self.stock_data.eval(factor_expression, engine='python')

    #         # 2. ì˜ˆì¸¡ ëŒ€ìƒ(target) ìƒì„±: ë‹¤ìŒ ë‚ ì˜ ìˆ˜ìµë¥ 
    #         target = self.stock_data.groupby('ticker')['close'].pct_change(1).shift(-1)

    #         # 3. ë°ì´í„°ì…‹ ì¤€ë¹„
    #         df_backtest = pd.DataFrame({
    #             'factor': factor_values,
    #             'target': target
    #         }).dropna()

    #         if len(df_backtest) < 100: # í•™ìŠµì— í•„ìš”í•œ ìµœì†Œ ë°ì´í„° ìˆ˜
    #             st.warning(f"'{factor_expression}' íŒ©í„° ê³„ì‚° í›„ ë°ì´í„°ê°€ ë„ˆë¬´ ì ì–´ ë°±í…ŒìŠ¤íŒ…ì„ ê±´ë„ˆëœë‹ˆë‹¤. (ë°ì´í„° ìˆ˜: {len(df_backtest)})")
    #             return 0.0

    #         X = df_backtest[['factor']]
    #         y = df_backtest['target']

        #     # 4. LightGBM ëª¨ë¸ í•™ìŠµ ë° ì˜ˆì¸¡
        #     model = lgb.LGBMRegressor(random_state=42, n_estimators=100)
        #     model.fit(X, y)
        #     predictions = model.predict(X)

        #     # 5. ì •ë³´ ê³„ìˆ˜(IC) ê³„ì‚°
        #     ic, _ = pearsonr(predictions, y)

        #     return float(ic)

        # except Exception as e:
        #     # ## ğŸ”‘ ì£¼ìš” ìˆ˜ì • ì‚¬í•­ ##
        #     # ì•„ë˜ st.warning ë¼ì¸ì˜ ì£¼ì„ì„ í•´ì œí•˜ì—¬ ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ í™”ë©´ì— ì¶œë ¥í•©ë‹ˆë‹¤.
        #     st.warning(f"'{factor_expression}' íŒ©í„° ë°±í…ŒìŠ¤íŒ… ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        #     return 0.0

    # def run_backtest(self, factor_expression: str) -> float:
    #     if self.stock_data.empty:
    #         st.warning("ì£¼ì‹ ë°ì´í„°ê°€ ì—†ì–´ ë°±í…ŒìŠ¤íŒ…ì„ ê±´ë„ˆëœë‹ˆë‹¤.")
    #         return 0.0

    #     try:
    #         # 1. ì‚¬ìš© ê°€ëŠ¥í•œ ì—°ì‚°ì í•¨ìˆ˜ë“¤ì„ ë™ì ìœ¼ë¡œ ë¡œë“œ
    #         operator_funcs = {
    #             name: func for name, func in inspect.getmembers(operators, inspect.isfunction)
    #             if not name.startswith('_')
    #         }

    #         # 3. pd.eval í˜¸ì¶œ
    #         # ë°ì´í„°í”„ë ˆì„ì˜ eval ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ê³ , local_dictë¡œ í•¨ìˆ˜ë¥¼ ì „ë‹¬í•©ë‹ˆë‹¤.
    #         factor_values = self.stock_data.eval(
    #             factor_expression, 
    #             local_dict=operator_funcs, 
    #             engine='python' # ë³µì¡í•œ í•¨ìˆ˜ í˜¸ì¶œì„ ìœ„í•´ python ì—”ì§„ ì‚¬ìš©
    #         )
            
    #         # 4. LightGBM ëª¨ë¸ í•™ìŠµ ë° ì˜ˆì¸¡
    #         model = lgb.LGBMRegressor(random_state=42, n_estimators=100)
    #         model.fit(X, y)
    #         predictions = model.predict(X)

    #         # 5. ì •ë³´ ê³„ìˆ˜(IC) ê³„ì‚°
    #         ic, _ = pearsonr(predictions, y)

    #         return float(ic)

    #     except Exception as e:
    #         # ## ğŸ”‘ ì£¼ìš” ìˆ˜ì • ì‚¬í•­ ##
    #         # ì•„ë˜ st.warning ë¼ì¸ì˜ ì£¼ì„ì„ í•´ì œí•˜ì—¬ ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ í™”ë©´ì— ì¶œë ¥í•©ë‹ˆë‹¤.
    #         st.warning(f"'{factor_expression}' íŒ©í„° ë°±í…ŒìŠ¤íŒ… ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
    #         return 0.0

    def run_backtest(self, factor_expression: str) -> float:
        """
        ì£¼ì–´ì§„ íŒ©í„° í‘œí˜„ì‹ì„ í‰ê°€í•˜ê³  LightGBMì„ ì‚¬ìš©í•˜ì—¬ ë°±í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.
        pd.eval()ê³¼ ëª…ì‹œì  ì‹¤í–‰ ë²”ìœ„ë¥¼ ì‚¬ìš©í•˜ì—¬ ì•ˆì •ì„±ì„ ë†’ì˜€ìŠµë‹ˆë‹¤.
        """
        if self.stock_data.empty:
            st.warning("ì£¼ì‹ ë°ì´í„°ê°€ ì—†ì–´ ë°±í…ŒìŠ¤íŒ…ì„ ê±´ë„ˆëœë‹ˆë‹¤.")
            return 0.0

        try:
            # 1. operators.pyì—ì„œ ì—°ì‚°ì í•¨ìˆ˜ë“¤ì„ ë™ì ìœ¼ë¡œ ë¡œë“œ
            operator_funcs = {
                name: func for name, func in inspect.getmembers(operators, inspect.isfunction)
                if not name.startswith('_')
            }

            # 2. ë°ì´í„°í”„ë ˆì„ì˜ ì»¬ëŸ¼ë“¤ì„ ë”•ì…”ë„ˆë¦¬ë¡œ ì¤€ë¹„
            data_vars = {col: self.stock_data[col] for col in self.stock_data.columns}

            # 3. ì—°ì‚°ì í•¨ìˆ˜ì™€ ë°ì´í„° ì»¬ëŸ¼ì„ í•˜ë‚˜ì˜ ì‹¤í–‰ ë²”ìœ„(scope)ë¡œ í†µí•©
            eval_scope = {**operator_funcs, **data_vars}

            # 4. ìµœìƒìœ„ pd.eval() í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ íŒ©í„° ê³„ì‚°
            # - local_dictì— í†µí•©ëœ ì‹¤í–‰ ë²”ìœ„ë¥¼ ì „ë‹¬í•˜ì—¬ ëª¨ë“  ë³€ìˆ˜ì™€ í•¨ìˆ˜ë¥¼ ì¸ì‹ì‹œí‚´
            # - global_dictë¥¼ ë¹„ì›Œë‘ì–´ ë³´ì•ˆ ê°•í™”
            factor_values = pd.eval(
                factor_expression,
                engine='python',
                local_dict=eval_scope,
                global_dict={}
            )

            # 5. ì˜ˆì¸¡ ëŒ€ìƒ(target) ìƒì„±: ë‹¤ìŒ ë‚ ì˜ ìˆ˜ìµë¥ 
            # ê·¸ë£¹ë³„(ticker)ë¡œ ìˆ˜ìµë¥ ì„ ê³„ì‚°í•˜ì—¬ ë°ì´í„° ì™œê³¡ ë°©ì§€
            target = self.stock_data.groupby(level='ticker')['close'].pct_change(1).shift(-1)

            # 6. ë°ì´í„°ì…‹ ì¤€ë¹„
            # factor_valuesì— ì›ë³¸ ë°ì´í„°í”„ë ˆì„ì˜ ì¸ë±ìŠ¤ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ë¶€ì—¬í•˜ì—¬ ì•ˆì •ì„± í™•ë³´
            df_backtest = pd.DataFrame({
                'factor': factor_values,
                'target': target
            }, index=self.stock_data.index).dropna()

            # 7. í•™ìŠµì— í•„ìš”í•œ ìµœì†Œ ë°ì´í„° ìˆ˜ í™•ì¸
            if len(df_backtest) < 100:
                st.warning(f"'{factor_expression}' íŒ©í„° ê³„ì‚° í›„ ë°ì´í„°ê°€ ë„ˆë¬´ ì ì–´ ë°±í…ŒìŠ¤íŒ…ì„ ê±´ë„ˆëœë‹ˆë‹¤. (ë°ì´í„° ìˆ˜: {len(df_backtest)})")
                return 0.0

            X = df_backtest[['factor']]
            y = df_backtest['target']

            # 8. LightGBM ëª¨ë¸ í•™ìŠµ ë° ì˜ˆì¸¡
            model = lgb.LGBMRegressor(random_state=42, n_estimators=100, verbosity=-1)
            model.fit(X, y)
            predictions = model.predict(X)

            # 9. ì •ë³´ ê³„ìˆ˜(IC) ê³„ì‚°
            # í”¼ì–´ìŠ¨ ìƒê´€ê³„ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì˜ˆì¸¡ê°’ê³¼ ì‹¤ì œê°’ì˜ ìƒê´€ê´€ê³„ ì¸¡ì •
            ic, _ = pearsonr(predictions, y)

            return float(ic)

        except Exception as e:
            # st.warning(f"'{factor_expression}' íŒ©í„° ë°±í…ŒìŠ¤íŒ… ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
            return 0.0
