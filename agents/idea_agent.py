# # -*- coding: utf-8 -*-
# """idea_agent

# Automatically generated by Colab.

# Original file is located at
#     https://colab.research.google.com/drive/13gorx4jIDXbX9wmGISGKisx2O8ZteZNu
# """

# # /agents/idea_agent.py

# import json
# from clients.llm_client import LLMClient

# class IdeaAgent:
#     """
#     시장 가설을 생성하고 개선하는 역할을 담당하는 에이전트.
#     LLM을 사용하여 사용자의 초기 아이디어를 구조화된 가설로 변환하고,
#     백테스팅 결과를 바탕으로 새로운 가설을 생성합니다.
#     """
#     def __init__(self, llm_client: LLMClient):
#         """
#         에이전트를 초기화합니다.

#         Args:
#             llm_client (LLMClient): LLM과 상호작용하기 위한 클라이언트.
#         """
#         self.llm_client = llm_client

#     def generate_initial_hypothesis(self, initial_insight: str) -> dict:
#         """
#         사용자의 초기 아이디어를 기반으로 첫 번째 시장 가설을 생성합니다.

#         Args:
#             initial_insight (str): 시장에 대한 사용자의 초기 아이디어 또는 관찰.

#         Returns:
#             dict: 구조화된 시장 가설.
#                   (예: {'knowledge', 'observation', 'justification', 'hypothesis', 'specification'})
#         """
#         system_prompt = """
#         당신은 월스트리트의 저명한 퀀트 분석가입니다. 당신의 임무는 주어진 사용자 인사이트를 바탕으로,
#         검증 가능한 정량적 투자 가설을 체계적으로 수립하는 것입니다.
#         결과는 반드시 다음의 5가지 요소를 포함하는 JSON 형식으로 응답해야 합니다:
#         1. knowledge: 가설의 기반이 되는 금융 이론이나 시장 원리.
#         2. observation: 현재 시장에서 관찰되는 구체적인 현상.
#         3. justification: 관찰된 현상이 금융 이론에 의해 어떻게 설명될 수 있는지 논리적 근거.
#         4. hypothesis: '만약 ~하다면, ~할 것이다' 형태의 명확하고 검증 가능한 가설.
#         5. specification: 가설을 팩터로 구현할 때 고려해야 할 구체적인 조건이나 파라미터.
#         """
#         user_prompt = f"다음 사용자 인사이트를 바탕으로 구조화된 투자 가설을 JSON 형식으로 생성해주세요:\n\n---\n{initial_insight}\n---"

#         response_text = self.llm_client.generate_text(user_prompt, system_prompt)
#         try:
#             return json.loads(response_text)
#         except json.JSONDecodeError:
#             print("오류: LLM이 유효한 JSON 형식의 가설을 생성하지 못했습니다.")
#             return {}

import json
import re # 정규 표현식 모듈 임포트

class IdeaAgent:
    """
    시장 가설을 생성하고 개선하는 역할을 담당하는 에이전트.
    LLM을 사용하여 사용자의 초기 아이디어를 구조화된 가설로 변환하고,
    백테스팅 결과를 바탕으로 새로운 가설을 생성합니다.
    """
    def __init__(self, llm_client: 'LLMClient'):
        """
        에이전트를 초기화합니다.

        Args:
            llm_client (LLMClient): LLM과 상호작용하기 위한 클라이언트.
        """
        self.llm_client = llm_client

    def generate_initial_hypothesis(self, initial_insight: str) -> dict:
        """
        사용자의 초기 아이디어를 기반으로 첫 번째 시장 가설을 생성합니다.

        Args:
            initial_insight (str): 시장에 대한 사용자의 초기 아이디어 또는 관찰.

        Returns:
            dict: 구조화된 시장 가설.
                  (예: {'knowledge', 'observation', 'justification', 'hypothesis', 'specification'})
        """
        system_prompt = """
        당신은 월스트리트의 저명한 퀀트 분석가입니다. 당신의 임무는 주어진 사용자 인사이트를 바탕으로,
        검증 가능한 정량적 투자 가설을 체계적으로 수립하는 것입니다.
        결과는 반드시 다음의 5가지 요소를 포함하는 JSON 형식으로 응답해야 합니다:
        1. knowledge: 가설의 기반이 되는 금융 이론이나 시장 원리.
        2. observation: 현재 시장에서 관찰되는 구체적인 현상.
        3. justification: 관찰된 현상이 금융 이론에 의해 어떻게 설명될 수 있는지 논리적 근거.
        4. hypothesis: '만약 ~하다면, ~할 것이다' 형태의 명확하고 검증 가능한 가설.
        5. specification: 가설을 팩터로 구현할 때 고려해야 할 구체적인 조건이나 파라미터.
        """
        user_prompt = f"다음 사용자 인사이트를 바탕으로 구조화된 투자 가설을 JSON 형식으로 생성해주세요:\n\n---\n{initial_insight}\n---"

        response_text = self.llm_client.generate_text(user_prompt, system_prompt)
        
        try:
            # LLM 응답에서 JSON 마크다운 블록 또는 순수 JSON 객체를 찾습니다.
            # re.DOTALL 플래그는 '.'이 줄바꿈 문자도 포함하도록 합니다.
            match = re.search(r'```json\s*(\{.*?\})\s*```|(\{.*?\})', response_text, re.DOTALL)
            
            if match:
                # 찾은 JSON 문자열을 추출합니다. (첫 번째 또는 두 번째 그룹)
                json_string = match.group(1) if match.group(1) else match.group(2)
                return json.loads(json_string)
            else:
                # 응답에서 JSON 형식을 찾지 못한 경우
                print("오류: LLM 응답에서 유효한 JSON 객체를 찾을 수 없습니다.")
                print(f"--- LLM 원본 응답 ---\n{response_text}\n--------------------")
                return {}

        except json.JSONDecodeError as e:
            # 추출된 문자열이 여전히 유효한 JSON이 아닌 경우
            print(f"오류: 추출된 문자열이 유효한 JSON이 아닙니다. (오류: {e})")
            print(f"--- LLM 원본 응답 ---\n{response_text}\n--------------------")
            return {}

    def refine_hypothesis(self, previous_results: dict) -> dict:
        """
        이전 백테스팅 결과를 바탕으로 기존 가설을 개선하거나 새로운 가설을 생성합니다.

        Args:
            previous_results (dict): 이전 주기의 평가 결과 요약.
                                     (예: {'best_factor': ..., 'average_ic': ...})

        Returns:
            dict: 새롭게 생성되거나 개선된 구조화된 시장 가설.
        """
        system_prompt = """
        당신은 실패로부터 배우는 뛰어난 퀀트 전략가입니다.
        이전 투자 전략의 성과 보고서를 보고, 실패 원인을 분석한 뒤,
        이를 개선할 수 있는 새롭고 창의적인 투자 가설을 제시해야 합니다.
        결과는 이전과 동일하게 5가지 요소를 포함하는 JSON 형식으로 응답해야 합니다.
        """
        user_prompt = f"다음은 이전 투자 아이디어의 성과 요약입니다. 이 결과를 분석하고, 더 나은 성과를 낼 수 있는 새로운 투자 가설을 JSON 형식으로 제안해주세요:\n\n---\n{json.dumps(previous_results, indent=2, ensure_ascii=False)}\n---"

        response_text = self.llm_client.generate_text(user_prompt, system_prompt)
        try:
            return json.loads(response_text)
        except json.JSONDecodeError:
            print("오류: LLM이 유효한 JSON 형식의 개선된 가설을 생성하지 못했습니다.")
            return {}


# import json
# import logging
# import re
# from typing import Dict, Any
# from clients.llm_client import LLMClient

# # 로깅 설정: print() 대신 logging 모듈 사용
# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
# logger = logging.getLogger(__name__)

# class IdeaAgent:
#     """
#     시장 가설을 생성하고 개선하는 역할을 담당하는 에이전트.
#     LLM을 사용하여 사용자의 초기 아이디어를 구조화된 가설로 변환하고,
#     백테스팅 결과를 바탕으로 새로운 가설을 생성합니다.
#     """
#     def __init__(self, llm_client: LLMClient, max_retries: int = 3):
#         """
#         에이전트를 초기화합니다.

#         Args:
#             llm_client (LLMClient): LLM과 상호작용하기 위한 클라이언트.
#             max_retries (int): JSON 파싱 실패 시 LLM 재시도 횟수.
#         """
#         self.llm_client = llm_client
#         self.max_retries = max_retries

#     def _safe_json_parse(self, response_text: str) -> Dict[str, Any]:
#         """
#         LLM 응답 텍스트에서 JSON을 안전하게 추출하고 파싱합니다.
        
#         Args:
#             response_text (str): LLM으로부터 받은 원본 텍스트 응답.
        
#         Returns:
#             Dict[str, Any]: 파싱된 JSON 데이터. 실패 시 빈 딕셔너리.
#         """
#         try:
#             # LLM 응답에 흔히 포함되는 마크다운 JSON 블록을 추출
#             # 예: ```json ... ```
#             json_match = re.search(r"```json(.*?)```", response_text, re.DOTALL)
#             if json_match:
#                 json_str = json_match.group(1).strip()
#             else:
#                 json_str = response_text.strip()
            
#             return json.loads(json_str)
#         except json.JSONDecodeError as e:
#             logger.error(f"JSON 파싱 오류: {e}")
#             logger.debug(f"원본 응답 텍스트: {response_text}")
#             return {}

#     def _generate_and_parse(self, user_prompt: str, system_prompt: str) -> dict:
#         """
#         LLM을 호출하고 JSON 파싱 실패 시 재시도하는 내부 메서드.
#         """
#         for retry in range(self.max_retries):
#             response_text = self.llm_client.generate_text(user_prompt, system_prompt)
#             parsed_data = self._safe_json_parse(response_text)
            
#             if parsed_data:
#                 logger.info("JSON 응답 파싱 성공.")
#                 return parsed_data
#             else:
#                 logger.warning(f"JSON 파싱 실패. 재시도 중... ({retry + 1}/{self.max_retries})")
#                 # 실패 원인에 대한 피드백을 프롬프트에 추가하는 로직을 고려할 수 있습니다.
                
#         logger.error(f"최대 재시도 횟수({self.max_retries}) 초과. JSON 파싱에 실패했습니다.")
#         return {}

#     def generate_initial_hypothesis(self, initial_insight: str) -> dict:
#         """
#         사용자의 초기 아이디어를 기반으로 첫 번째 시장 가설을 생성합니다.
#         """
#         system_prompt = """
#         당신은 월스트리트의 저명한 퀀트 분석가입니다. 당신의 임무는 주어진 사용자 인사이트를 바탕으로,
#         검증 가능한 정량적 투자 가설을 체계적으로 수립하는 것입니다.
#         결과는 반드시 다음의 5가지 요소를 포함하는 **유효한 JSON 형식**으로만 응답해야 합니다:
#         1. knowledge: 가설의 기반이 되는 금융 이론이나 시장 원리.
#         2. observation: 현재 시장에서 관찰되는 구체적인 현상.
#         3. justification: 관찰된 현상이 금융 이론에 의해 어떻게 설명될 수 있는지 논리적 근거.
#         4. hypothesis: '만약 ~하다면, ~할 것이다' 형태의 명확하고 검증 가능한 가설.
#         5. specification: 가설을 팩터로 구현할 때 고려해야 할 구체적인 조건이나 파라미터.
#         """
#         user_prompt = f"다음 사용자 인사이트를 바탕으로 구조화된 투자 가설을 JSON 형식으로 생성해주세요:\n\n---\n{initial_insight}\n---"

#         return self._generate_and_parse(user_prompt, system_prompt)

#     def refine_hypothesis(self, previous_results: dict) -> dict:
#         """
#         이전 백테스팅 결과를 바탕으로 기존 가설을 개선하거나 새로운 가설을 생성합니다.
#         """
#         system_prompt = """
#         당신은 실패로부터 배우는 뛰어난 퀀트 전략가입니다.
#         이전 투자 전략의 성과 보고서를 보고, 실패 원인을 분석한 뒤,
#         이를 개선할 수 있는 새롭고 창의적인 투자 가설을 제시해야 합니다.
#         결과는 이전과 동일하게 5가지 요소를 포함하는 **유효한 JSON 형식**으로만 응답해야 합니다.
#         """
#         user_prompt = f"다음은 이전 투자 아이디어의 성과 요약입니다. 이 결과를 분석하고, 더 나은 성과를 낼 수 있는 새로운 투자 가설을 JSON 형식으로 제안해주세요:\n\n---\n{json.dumps(previous_results, indent=2, ensure_ascii=False)}\n---"

#         return self._generate_and_parse(user_prompt, system_prompt)
