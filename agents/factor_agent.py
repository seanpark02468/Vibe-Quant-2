# -*- coding: utf-8 -*-
"""factor_agent

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cHNNPHlGJD05SggoSjPqrDJz4flcTsbp
"""

# /agents/factor_agent.py

# import json
# from clients.llm_client import LLMClient

# class FactorAgent:
#     """
#     시장 가설을 구체적인 알파 팩터 표현식으로 변환하는 에이전트.
#     LLM을 활용하여 가설의 논리를 따르는 여러 후보 팩터를 생성합니다.
#     """
#     def __init__(self, llm_client: LLMClient):
#         """
#         에이전트를 초기화합니다.

#         Args:
#             llm_client (LLMClient): LLM과 상호작용하기 위한 클라이언트.
#         """
#         self.llm_client = llm_client
#         # 사용 가능한 Operator 목록 (실제로는 operators.py에서 동적으로 로드할 수 있음)
#         self.available_operators = [
#             'sign', 'delay', 'delta', 'correlation', 'covariance', 'ts_min',
#             'ts_max', 'ts_argmin', 'ts_argmax', 'ts_rank', 'stddev', 'sum',
#             'product', 'decay_linear', 'rank', 'scale', 'indneutralize'
#         ]

#     def create_factors(self, hypothesis: dict, num_factors: int = 3) -> list:
#         """
#         주어진 가설을 바탕으로 여러 개의 알파 팩터 후보를 생성합니다.

#         Args:
#             hypothesis (dict): IdeaAgent가 생성한 구조화된 가설.
#             num_factors (int): 생성할 팩터 후보의 수.

#         Returns:
#             list: 각 요소가 팩터의 설명과 수식을 담은 딕셔너리 리스트.
#                   (예: [{'description': '...', 'formula': '...'}, ...])
#         """
#         system_prompt = f"""
#         당신은 파이썬과 pandas 라이브러리에 능숙한 퀀트 개발자입니다.
#         주어진 투자 가설을 수학적 표현식(알파 팩터)으로 구현해야 합니다.
#         반드시 다음 규칙을 따라야 합니다:
#         1. 최종 결과는 JSON 형식의 리스트여야 하며, 각 요소는 'description'과 'formula' 키를 가진 객체입니다.
#         2. 'formula'는 pandas에서 `df.eval()`로 실행 가능한 파이썬 코드여야 합니다.
#         3. 'formula'를 작성할 때, 기본 데이터 컬럼('open', 'high', 'low', 'close', 'volume')과
#            다음의 허용된 함수(오퍼레이터) 목록만을 사용해야 합니다: {', '.join(self.available_operators)}.
#         4. 허용되지 않은 함수나 라이브러리(예: np.log, talib 등)는 절대 사용하면 안 됩니다.
#         5. 가설의 핵심 아이디어를 반영하는 창의적이고 다양한 {num_factors}개의 팩터를 생성해주세요.
#         """
#         user_prompt = f"다음 가설을 바탕으로, 규칙에 맞는 알파 팩터 {num_factors}개를 JSON 리스트 형식으로 생성해주세요:\n\n---\n{json.dumps(hypothesis, indent=2, ensure_ascii=False)}\n---"

#         response_text = self.llm_client.generate_text(user_prompt, system_prompt)
#         try:
#             factors = json.loads(response_text)
#             if isinstance(factors, list) and all('formula' in f for f in factors):
#                 return factors
#             else:
#                 raise ValueError
#         except (json.JSONDecodeError, ValueError):
#             print("오류: LLM이 유효한 JSON 형식의 팩터 리스트를 생성하지 못했습니다.")
#             return []

# import json
# import re  # 정규 표현식 모듈 임포트
# from clients.llm_client import LLMClient
# import inspect
# from core import operators

# class FactorAgent:
#     """
#     시장 가설을 구체적인 알파 팩터 표현식으로 변환하는 에이전트.
#     LLM을 활용하여 가설의 논리를 따르는 여러 후보 팩터를 생성합니다.
#     """
#     def __init__(self, llm_client: LLMClient):
#         """
#         에이전트를 초기화합니다.

#         Args:
#             llm_client (LLMClient): LLM과 상호작용하기 위한 클라이언트.
#         """
#         # self.llm_client = llm_client
#         # # 사용 가능한 Operator 목록
#         # self.available_operators = [
#         #     'sign', 'delay', 'delta', 'correlation', 'covariance', 'ts_min',
#         #     'ts_max', 'ts_argmin', 'ts_argmax', 'ts_rank', 'stddev', 'sum',
#         #     'product', 'decay_linear', 'rank', 'scale', 'indneutralize'
#         # ]

#         self.llm_client = llm_client
#         # operators.py에서 '_'로 시작하지 않는 모든 함수 이름을 동적으로 로드
#         self.available_operators = [
#             name for name, func in inspect.getmembers(operators, inspect.isfunction)
#             if not name.startswith('_')
#         ]    

#     def create_factors(self, hypothesis: dict, num_factors: int = 3) -> list:
#         """
#         주어진 가설을 바탕으로 여러 개의 알파 팩터 후보를 생성합니다.

#         Args:
#             hypothesis (dict): IdeaAgent가 생성한 구조화된 가설.
#             num_factors (int): 생성할 팩터 후보의 수.

#         Returns:
#             list: 각 요소가 팩터의 설명과 수식을 담은 딕셔너리 리스트.
#         """
#         system_prompt = f"""
#         당신은 파이썬과 pandas 라이브러리에 능숙한 퀀트 개발자입니다.
#         주어진 투자 가설을 수학적 표현식(알파 팩터)으로 구현해야 합니다.
#         반드시 다음 규칙을 따라야 합니다:
#         1. 최종 결과는 JSON 형식의 리스트여야 하며, 각 요소는 'description'과 'formula' 키를 가진 객체입니다.
#         2. 'formula'는 pandas에서 `pd.eval()`로 실행 가능한 파이썬 코드여야 합니다.
#         3. 'formula'를 작성할 때, 기본 데이터 컬럼('open', 'high', 'low', 'close', 'volume')과
#            다음의 허용된 함수(오퍼레이터) 목록만을 사용해야 합니다: {', '.join(self.available_operators)}.
#         4. 허용되지 않은 함수나 라이브러리(예: np.log, talib 등)는 절대 사용하면 안 됩니다.
#         5. 가설의 핵심 아이디어를 반영하는 창의적이고 다양한 {num_factors}개의 팩터를 생성해주세요.
#         """
#         user_prompt = f"다음 가설을 바탕으로, 규칙에 맞는 알파 팩터 {num_factors}개를 JSON 리스트 형식으로 생성해주세요:\n\n---\n{json.dumps(hypothesis, indent=2, ensure_ascii=False)}\n---"

#         response_text = self.llm_client.generate_text(user_prompt, system_prompt)
        
#         try:
#             # LLM 응답에서 JSON 리스트('[...]' 형태)만 추출합니다.
#             # re.DOTALL 플래그는 '.'이 줄바꿈 문자도 포함하도록 합니다.
#             match = re.search(r'```json\s*(\[.*?\])\s*```|(\[.*?\])', response_text, re.DOTALL)
            
#             if not match:
#                 # LLM 응답에서 리스트 형식을 찾지 못한 경우
#                 print("오류: LLM 응답에서 유효한 JSON 리스트를 찾을 수 없습니다.")
#                 print(f"--- LLM 원본 응답 ---\n{response_text}\n--------------------")
#                 return []

#             # 찾은 JSON 문자열을 추출합니다.
#             json_string = match.group(1) if match.group(1) else match.group(2)
#             factors = json.loads(json_string)

#             # 파싱된 결과가 유효한 형식인지 다시 한번 확인합니다.
#             if isinstance(factors, list) and all(isinstance(f, dict) and 'formula' in f for f in factors):
#                 return factors
#             else:
#                 print("오류: 파싱된 데이터가 유효한 팩터 리스트 형식이 아닙니다.")
#                 print(f"--- LLM 원본 응답 ---\n{response_text}\n--------------------")
#                 return []

#         except json.JSONDecodeError as e:
#             # 추출된 문자열이 여전히 유효한 JSON이 아닌 경우
#             print(f"오류: 추출된 문자열이 유효한 JSON이 아닙니다. (오류: {e})")
#             print(f"--- LLM 원본 응답 ---\n{response_text}\n--------------------")
#             return []

import json
import re
import inspect
from pathlib import Path
from clients.llm_client import LLMClient
from core import operators
# from agents import operators

class FactorAgent:
    def __init__(self, llm_client: LLMClient):
        self.llm_client = llm_client

        # operator.json 불러오기
        operator_json_path = Path(__file__).parent.parent / "agents" / "operators.json"
        with open(operator_json_path, "r", encoding="utf-8") as f:
            self.operator_info = json.load(f)

        # 허용 연산자 리스트
        self.available_operators = list(self.operator_info.keys())

    def create_factors(self, hypothesis: dict, num_factors: int = 3) -> list:
        # system_prompt 생성
#         system_prompt = f"""
# 당신은 파이썬과 pandas 라이브러리에 능숙한 퀀트 개발자입니다.
# 주어진 투자 가설을 수학적 표현식(알파 팩터)으로 구현해야 합니다.

# ⚠️ 반드시 아래 규칙을 따르세요:
# 1. 최종 결과는 JSON 형식의 리스트여야 하며, 각 요소는 반드시 "description"과 "formula" 키를 가진 객체입니다.
# 2. "formula"는 pandas의 `df.eval()`에서 실행 가능한 파이썬 표현식이어야 합니다.
# 3. "formula" 작성 시, 기본 데이터 컬럼('open', 'high', 'low', 'close', 'volume')과
#    아래 [허용 오퍼레이터 사전]에 명시된 함수만 사용해야 합니다.
# 4. 허용되지 않은 함수나 라이브러리(예: np.log, talib 등)는 절대 사용하면 안 됩니다.
# 5. 함수 호출 시 반드시 [허용 오퍼레이터 사전]에 있는 정확한 함수명만 사용하세요.
# 6. 가설의 핵심 아이디어를 반영하는 창의적이고 다양한 {num_factors}개의 팩터를 생성하세요.

# [허용 오퍼레이터 사전: 함수명 → 설명]
# {json.dumps(self.operator_info, ensure_ascii=False, indent=2)}

# 출력 예시:
# [
#   {{
#     "description": "최근 5일간 수익률 변동성이 낮은 종목에 투자",
#     "formula": "1 / (stddev(close, 5) + 1e-6)"
#   }},
#   ...
# ]
# """.strip()
        system_prompt = f"""
You are an experienced Python and pandas quant developer.
Your task is to convert the given investment hypothesis into mathematical alpha factor expressions.

You MUST strictly follow these rules:

1. **Output Format**
   - The final output MUST be a valid JSON array.
   - Each element MUST be an object with exactly two keys:
     - "description": a concise human-readable explanation of the factor.
     - "formula": a Python expression that can be evaluated by `pandas.DataFrame.eval()`.

2. **Allowed Variables**
   - You may ONLY use the following base data columns:
     - 'open', 'high', 'low', 'close', 'volume'

3. **Allowed Functions (Operators)**
   - You may ONLY use functions listed in the "Allowed Operators Dictionary" below.
   - You MUST use the function names exactly as written (case-sensitive).
   - No other functions, libraries, or methods are allowed.
   - Attribute access (e.g., `obj.attr`) is strictly forbidden.

4. **Prohibited**
   - Any function or variable not listed below.
   - Any import statements, external libraries (e.g., numpy, talib).
   - Any access to object attributes or private members.
   - Any string output outside the JSON array.

5. **Factor Requirements**
   - Create {num_factors} different factors.
   - Each formula should return a vector/Series compatible with the DataFrame’s index.
   - Be creative but stay within the constraints.

[Allowed Operators Dictionary: function_name → description]
{json.dumps(self.operator_info, ensure_ascii=False, indent=2)}

Example output:
[
  {{
    "description": "Invest in assets with low 5-day return volatility",
    "formula": "1 / (stddev(close, 5) + 1e-6)"
  }},
  {{
    "description": "Price momentum over the last 10 days",
    "formula": "delta(close, 10)"
  }}
]
""".strip()

        user_prompt = f"다음 가설을 바탕으로, 규칙에 맞는 알파 팩터 {num_factors}개를 JSON 리스트 형식으로 생성해주세요:\n\n---\n{json.dumps(hypothesis, indent=2, ensure_ascii=False)}\n---"

        # LLM 호출
        response_text = self.llm_client.generate_text(user_prompt, system_prompt)

        # JSON 추출
        match = re.search(r'```json\s*(\[.*?\])\s*```|(\[.*?\])', response_text, re.DOTALL)
        if not match:
            return []
        json_string = match.group(1) if match.group(1) else match.group(2)

        try:
            factors = json.loads(json_string)
            if isinstance(factors, list) and all(isinstance(f, dict) and 'formula' in f for f in factors):
                return factors
        except json.JSONDecodeError:
            return []

        return []
